{"data":{"site":{"siteMetadata":{"title":"devLog","author":"Junho Baik"}},"markdownRemark":{"id":"/Users/junhobaik/Development/junhobaik.github.io/_posts/2017/2017-10-16-js-number-type.md absPath of file >>> MarkdownRemark","html":"<p>Javascript는 Java와 달리 int, double 같은 숫자 타입이 나눠져있지 않다.<br>\nnumber 하나로 정수(Integer)와 부동 소수점 수를 모두 표현한다.</p>\n<h3>숫자 리터럴</h3>\n<pre><code class=\"language-javascript\">var n = 12 //12\nn = 12. //12\nn = 12.0 //12\nn = 12.300 //12.3\nn = 0.12 //0.12\nn = .12 //0.12\n</code></pre>\n<p>.12, 12. 과 같은 방식은 틀린 것은 아니더라도 좋은 코드라고 하긴 어려울 것이다.</p>\n<h3>Number Methods</h3>\n<h4>- Number.isInteger()</h4>\n<p>정수인지 확인할 수 있는 메서드.</p>\n<pre><code class=\"language-javascript\">var n = 12;\nNumber.isInteger(n); // true\nn = .12;\nNumber.isInteger(n); // false\n</code></pre>\n<h4>- Number.isSafeInteger()   <strong>/*ES6*/</strong></h4>\n<p>안전한 정수값인 <code>-(253 - 1)</code> 부터 <code>253 - 1</code> 사이의 정수 값인지 확인하는 메서드, ES6에서 출현하였다.</p>\n<pre><code class=\"language-javascript\">Number.isSafeInteger(100);                    // true\nNumber.isSafeInteger(Math.pow(2, 53));      // false\nNumber.isSafeInteger(Math.pow(2, 53) - 1);  // true\n</code></pre>\n<h4>- Number.toFixed()</h4>\n<p>인자로 넘긴 수 만큼의 소수점 이하를 반올림하여 문자열 형태로 반환하는 메서드.</p>\n<pre><code class=\"language-javascript\">var n = 12.39;\nn.toFixed(0); //\"12\"\nn.toFixed(1); //\"12.4\"\nn.toFixed(2); //\"12.39\"\nn.toFixed(3); //\"12.390\"\n</code></pre>\n<h4>- Number.toPrecision()</h4>\n<p>수의 길이를 제한하여 문자열로 반환한다.</p>\n<pre><code class=\"language-javascript\">var n = 12.39;\nn.toPrecision() //\"12.39\"\nn.toPrecision(1) //\"1e+1\"\nn.toPrecision(2) //\"12\"\nn.toPrecision(3) //\"12.4\"\nn.toPrecision(4) //\"12.39\"\n</code></pre>\n<h4>- Number.toExponential()</h4>\n<p>수를 지수표현식 문자열으로 반환한다.</p>\n<pre><code class=\"language-javascript\">var n = 10000000000;\nn; // 10000000000\nn.toExponential(); //\"1e+10\"\n</code></pre>\n<hr>\n<h3>0.5 === 0.2 + 0.3 // false ??</h3>\n<p>Java나 타 언어를 배워봤다면 한번은 봤을만한 질문이다. </p>\n<p>0.5와 같은 부동 소수점 수는 결국 프로그래밍 언어에서는 0.5000000001과 같이 0.5와 가까운 수이기 때문이라는 것인데...</p>\n<p>Javascript에서는 어떨까?</p>\n<p>아래는 크롬 브라우저(2017.10 최신버전)의 콘솔창 결과이다.</p>\n<pre><code class=\"language-javascript\">0.0000005 === 0.0000002 + 0.0000003;\ntrue\n0.000005 === 0.000002 + 0.000003;\nfalse\n0.00005 === 0.00002 + 0.00003;\ntrue\n0.0005 === 0.0002 + 0.0003;\ntrue\n0.005 === 0.002 + 0.003;\ntrue\n0.05 === 0.02 + 0.03;\ntrue\n0.5 === 0.2 + 0.3;\ntrue\n\n0.1 + 0.2 === 0.3\nfalse\n\n1.2 - 1 \n0.19999999999999996\n1.5 - 0.5\n1\n</code></pre>\n<p>모두 true 이길 바라지만 결과는 그렇지 않다. 더 어려운 것은 모두 false도 아니라는 것이다.</p>\n<p>어떤 것은 true이고 어떤 것은 false인 이러한 이유는 아직까지 정확하게 찾지 못했지만 부동 소수점 수의 계산에 있어 조심해야한다는 것을 알 수 있다.</p>\n<h5>해결 방법</h5>\n<pre><code class=\"language-javascript\">(1.2 - 1).toFixed(1) * 1 // 0.2\n(1.1000001 - 1).toFixed(7) * 1 // 0.1000001\n</code></pre>\n<p>Number의 메서드를 사용하여 위와 같은 방법으로 해결하는 방법도 있다.</p>","frontmatter":{"title":"자바스크립트의 숫자 타입(Number Type)","date":"October 16, 2017"}}},"pageContext":{"slug":"/js-number-type/","previous":{"fields":{"slug":"/js-es6-set-map/"},"frontmatter":{"title":"자바스크립트 ES6 Set, WeakSet / Map, WeakMap","tags":["javascript","ES6"]}},"next":{"fields":{"slug":"/js-semicolon-asi/"},"frontmatter":{"title":"자바스크립트에서 세미콜론(;)을 안써도 될까?","tags":["javascript"]}}}}