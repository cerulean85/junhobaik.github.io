{"data":{"site":{"siteMetadata":{"title":"devLog","author":"Junho Baik"}},"markdownRemark":{"id":"/Users/junhobaik/Development/junhobaik.github.io/_posts/2017/2017-04-19-js-clouser.md absPath of file >>> MarkdownRemark","html":"<ul>\n<li>함수, 함수가 선언될 때의 environment로 구성  </li>\n<li>함수가 정의 될 때의 environment가 함께 closure로 결합되면서, 다양한 활용이 가능  </li>\n</ul>\n<pre><code class=\"language-js\">function makeCounterFunction(initVal){\n    var count = initVal;\n    function Increase(){\n        count++;\n        console.log(count);\n    }\n    return Increase;\n}\n\nvar counter1 = makeCounterFunction(0);\nvar counter2 = makeCounterFunction(10);\n</code></pre>\n<ul>\n<li>\n<p>counter1의 closure</p>\n<ul>\n<li>함수 : function Increase(){}</li>\n<li>환경 : var count = 0;</li>\n</ul>\n</li>\n<li>\n<p>counter2의 closure</p>\n<ul>\n<li>함수 : function Increase(){}</li>\n<li>환경 : var count = 10;\n여기서 counter1, counter2 함수가지고는 count 변수의 값을 직접 제어할 수 없다, count 변수는 makecounterfunction 안에 있고 여기선 increse함수밖에 없기때문이다. 이 원리를 이용해 private한 변수를 활용할 수 있다 아래서 확인해보자.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>간단하게 클로저의 두가지 개념을 이해하도록 하자.  </p>\n<ol>\n<li>외부 함수가 소멸된 뒤에도 내부 함수는 외부 함수의 지역 변수에 접근 할 수 있다.  </li>\n<li>클로저를 이용하여 private한 변수를 만들 수 있다.  </li>\n</ol>\n<p>1번의 예</p>\n<pre><code class=\"language-js\">function sum() {\n    var num = 0;\n    console.log(num);\n    function addsum() {\n        console.log(num);\n        num++;\n        return num;\n    }\n    return addsum;\n}\nvar a = sum(); \n// function addsum(){...}\n// 여기서 sum 함수는 수명이 끝남.\n\na();\n// 여기서 addsum()을 하게 되는 꼴인데,\n// num을 증가시키는 부분에서 num은 클로저에 담긴 num이다.\n// Closure(sum) num: 0\n\na();\n// Closure(sum) num: 1\n\na();\n// Closure(sum) num: 2\n</code></pre>\n<p>2번의 예</p>\n<pre><code class=\"language-js\">function people(name) {\n    return {\n        get_name: function () {\n            console.log(name);\n            return name;\n        },\n        set_name: function (_name) {\n            console.log(name);\n            name = _name;\n        }\n    }\n}\nvar junho = people(\"junhobaik\"); \n//여기서 외부 함수의 인자로 값을 넘긴다.\n//함수에서는 전달 받은 값을 직접 조작할 수 없게 되고\n//get,set_name을 통해서만 접근 할 수 있게 된다.\n//이렇게 사용하는 방법으로 private한 변수를 만들 수 있다.\n\njunho.get_name(); \n//이때 실행되는 get_name의 console.log에서 name값은 closure(people) name:'junhobaik' 이다.\n</code></pre>\n<hr>\n<h3>추가 내용</h3>\n<pre><code class=\"language-html\">&#x3C;button id=\"btn0\">버튼 1&#x3C;/button>\n&#x3C;button id=\"btn1\">버튼 2&#x3C;/button>\n&#x3C;button id=\"btn2\">버튼 3&#x3C;/button>\n&#x3C;script> \n    for (var i = 0; i &#x3C; 3; i++) {\n        document.getElementById('btn' + i).addEventListener(\"click\", function () {\n            console.log(\"Click btn\", i+1);\n        });\n    }\n&#x3C;/script>\n</code></pre>\n<p>기대하는 결과는 Click btn1,2,3 하지만 실제 결과는 Click btn3,3,3<br>\n그 이유는 아래와 같다.  </p>\n<ol>\n<li>for문을 돌며 버튼 1,2,3에 이벤트가 등록되며 콜백함수또한 등록된다. (여기서 위에서 살펴본 설명으로 이벤트는 외부함수, 콜백함수는 내부함수라고 할 수 있다)</li>\n<li>이벤트가 등록되면서 이벤트 함수는 스택에서 떠난다 (소멸되었다)</li>\n<li>따라서 콜백함수는 클로저 i값에 접근하게 되는데 클로저 i값은 콜백함수 모두가 공유하게 되는 값이다.</li>\n<li>for문을 통해 증가가 완료된 값이 클로저에 남아있고, 그 클로저 값이 계속해서 노출되는 것이다.</li>\n</ol>\n<p>해결 방법  </p>\n<ol>\n<li>let을 이용한 block scope 생성을 통한 해결</li>\n<li>이벤트 함수(외부함수)를 또 함수로 묶어 새로운 scope를 만들어낸다.</li>\n</ol>","frontmatter":{"title":"자바스크립트 클로저(Closure)","date":"April 19, 2017"}}},"pageContext":{"slug":"/js-clouser/","previous":{"fields":{"slug":"/js-prototype/"},"frontmatter":{"title":"자바스크립트 프로토타입(Prototype)","tags":["javascript"]}},"next":{"fields":{"slug":"/js-this/"},"frontmatter":{"title":"자바스크립트 this","tags":["javascript"]}}}}